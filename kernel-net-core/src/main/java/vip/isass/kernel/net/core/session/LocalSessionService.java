/*
 *                     GNU LESSER GENERAL PUBLIC LICENSE
 *                         Version 3, 29 June 2007
 *
 *   Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 *   Everyone is permitted to copy and distribute verbatim copies
 *   of this license document, but changing it is not allowed.
 *
 *
 *    This version of the GNU Lesser General Public License incorporates
 *  the terms and conditions of version 3 of the GNU General Public
 *  License, supplemented by the additional permissions listed below.
 *
 *    0. Additional Definitions.
 *
 *    As used herein, "this License" refers to version 3 of the GNU Lesser
 *  General Public License, and the "GNU GPL" refers to version 3 of the GNU
 *  General Public License.
 *
 *    "The Library" refers to a covered work governed by this License,
 *  other than an Application or a Combined Work as defined below.
 *
 *    An "Application" is any work that makes use of an interface provided
 *  by the Library, but which is not otherwise based on the Library.
 *  Defining a subclass of a class defined by the Library is deemed a mode
 *  of using an interface provided by the Library.
 *
 *    A "Combined Work" is a work produced by combining or linking an
 *  Application with the Library.  The particular version of the Library
 *  with which the Combined Work was made is also called the "Linked
 *  Version".
 *
 *    The "Minimal Corresponding Source" for a Combined Work means the
 *  Corresponding Source for the Combined Work, excluding any source code
 *  for portions of the Combined Work that, considered in isolation, are
 *  based on the Application, and not on the Linked Version.
 *
 *    The "Corresponding Application Code" for a Combined Work means the
 *  object code and/or source code for the Application, including any data
 *  and utility programs needed for reproducing the Combined Work from the
 *  Application, but excluding the System Libraries of the Combined Work.
 *
 *    1. Exception to Section 3 of the GNU GPL.
 *
 *    You may convey a covered work under sections 3 and 4 of this License
 *  without being bound by section 3 of the GNU GPL.
 *
 *    2. Conveying Modified Versions.
 *
 *    If you modify a copy of the Library, and, in your modifications, a
 *  facility refers to a function or data to be supplied by an Application
 *  that uses the facility (other than as an argument passed when the
 *  facility is invoked), then you may convey a copy of the modified
 *  version:
 *
 *     a) under this License, provided that you make a good faith effort to
 *     ensure that, in the event an Application does not supply the
 *     function or data, the facility still operates, and performs
 *     whatever part of its purpose remains meaningful, or
 *
 *     b) under the GNU GPL, with none of the additional permissions of
 *     this License applicable to that copy.
 *
 *    3. Object Code Incorporating Material from Library Header Files.
 *
 *    The object code form of an Application may incorporate material from
 *  a header file that is part of the Library.  You may convey such object
 *  code under terms of your choice, provided that, if the incorporated
 *  material is not limited to numerical parameters, data structure
 *  layouts and accessors, or small macros, inline functions and templates
 *  (ten or fewer lines in length), you do both of the following:
 *
 *     a) Give prominent notice with each copy of the object code that the
 *     Library is used in it and that the Library and its use are
 *     covered by this License.
 *
 *     b) Accompany the object code with a copy of the GNU GPL and this license
 *     document.
 *
 *    4. Combined Works.
 *
 *    You may convey a Combined Work under terms of your choice that,
 *  taken together, effectively do not restrict modification of the
 *  portions of the Library contained in the Combined Work and reverse
 *  engineering for debugging such modifications, if you also do each of
 *  the following:
 *
 *     a) Give prominent notice with each copy of the Combined Work that
 *     the Library is used in it and that the Library and its use are
 *     covered by this License.
 *
 *     b) Accompany the Combined Work with a copy of the GNU GPL and this license
 *     document.
 *
 *     c) For a Combined Work that displays copyright notices during
 *     execution, include the copyright notice for the Library among
 *     these notices, as well as a reference directing the user to the
 *     copies of the GNU GPL and this license document.
 *
 *     d) Do one of the following:
 *
 *         0) Convey the Minimal Corresponding Source under the terms of this
 *         License, and the Corresponding Application Code in a form
 *         suitable for, and under terms that permit, the user to
 *         recombine or relink the Application with a modified version of
 *         the Linked Version to produce a modified Combined Work, in the
 *         manner specified by section 6 of the GNU GPL for conveying
 *         Corresponding Source.
 *
 *         1) Use a suitable shared library mechanism for linking with the
 *         Library.  A suitable mechanism is one that (a) uses at run time
 *         a copy of the Library already present on the user's computer
 *         system, and (b) will operate properly with a modified version
 *         of the Library that is interface-compatible with the Linked
 *         Version.
 *
 *     e) Provide Installation Information, but only if you would otherwise
 *     be required to provide such information under section 6 of the
 *     GNU GPL, and only to the extent that such information is
 *     necessary to install and execute a modified version of the
 *     Combined Work produced by recombining or relinking the
 *     Application with a modified version of the Linked Version. (If
 *     you use option 4d0, the Installation Information must accompany
 *     the Minimal Corresponding Source and Corresponding Application
 *     Code. If you use option 4d1, you must provide the Installation
 *     Information in the manner specified by section 6 of the GNU GPL
 *     for conveying Corresponding Source.)
 *
 *    5. Combined Libraries.
 *
 *    You may place library facilities that are a work based on the
 *  Library side by side in a single library together with other library
 *  facilities that are not Applications and are not covered by this
 *  License, and convey such a combined library under terms of your
 *  choice, if you do both of the following:
 *
 *     a) Accompany the combined library with a copy of the same work based
 *     on the Library, uncombined with any other library facilities,
 *     conveyed under the terms of this License.
 *
 *     b) Give prominent notice with the combined library that part of it
 *     is a work based on the Library, and explaining where to find the
 *     accompanying uncombined form of the same work.
 *
 *    6. Revised Versions of the GNU Lesser General Public License.
 *
 *    The Free Software Foundation may publish revised and/or new versions
 *  of the GNU Lesser General Public License from time to time. Such new
 *  versions will be similar in spirit to the present version, but may
 *  differ in detail to address new problems or concerns.
 *
 *    Each version is given a distinguishing version number. If the
 *  Library as you received it specifies that a certain numbered version
 *  of the GNU Lesser General Public License "or any later version"
 *  applies to it, you have the option of following the terms and
 *  conditions either of that published version or of any later version
 *  published by the Free Software Foundation. If the Library as you
 *  received it does not specify a version number of the GNU Lesser
 *  General Public License, you may choose any version of the GNU Lesser
 *  General Public License ever published by the Free Software Foundation.
 *
 *    If the Library as you received it specifies that a proxy can decide
 *  whether future versions of the GNU Lesser General Public License shall
 *  apply, that proxy's public statement of acceptance of any version is
 *  permanent authorization for you to choose that version for the
 *  Library.
 *
 */

package vip.isass.kernel.net.core.session;

import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.lang.Assert;
import cn.hutool.core.map.MapUtil;
import cn.hutool.core.util.StrUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.annotation.Configuration;
import vip.isass.core.map.MultiKeyMultiValueBiMap;
import vip.isass.core.map.MultiValueBiMap;
import vip.isass.kernel.net.core.message.Message;

import javax.annotation.Nonnull;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * 会话管理器抽象类
 *
 * @author Rain
 */
@Slf4j
@Configuration
@ConditionalOnMissingBean(name = "sessionServiceClientProxy")
public class LocalSessionService implements ISessionService {

    // region sessionId 和 session 关系

    /**
     * 保存所有会话
     * <p> {@literal Map<sessionId, Session>}
     */
    private final Map<String, Session<?>> sessionMap = new ConcurrentHashMap<>();

    /**
     * 所有会话 map 的不可变 map
     */
    private final Map<String, Session<?>> unmodifiableSessionMap = Collections.unmodifiableMap(sessionMap);

    // endregion

    private final MultiValueBiMap<String, String> userAndSessionMap = new MultiValueBiMap<>();

    private final MultiValueBiMap<String, String> aliasAndSessionMap = new MultiValueBiMap<>();

    private final MultiKeyMultiValueBiMap<String, String> sessionAndTagMap = new MultiKeyMultiValueBiMap<>();

    // region session

    @Override
    public void addSession(Session<?> session) {
        Assert.notNull(session, "session 不能为 null");
        sessionMap.put(session.getSessionId(), session);
    }

    @Override
    public Session<?> removeSession(String sessionId) {
        Session<?> remove = sessionMap.remove(sessionId);
        if (remove != null) {
            removeUserId(sessionId);
            removeAlias(sessionId);
            removeTags(sessionId);
        }
        return remove;
    }

    @Override
    public Session<?> getSessionById(String sessionId) {
        return sessionMap.get(sessionId);
    }

    // @Override
    // public Collection<String> findSessionIds(String userId) {
    //     return userAndSessionMap.get(userId);
    // }

    @Override
    public Collection<Session<?>> findAllSessions() {
        return unmodifiableSessionMap.values();
    }

    // endregion

    // region user

    @Override
    public String getUserId(String sessionId) {
        return userAndSessionMap.getKey(sessionId);
    }

    @Override
    public void setUserId(String sessionId, String userId) {
        Session<?> session = sessionMap.get(sessionId);
        if (session == null) {
            return;
        }
        userAndSessionMap.removeValue(sessionId);
        userAndSessionMap.put(userId, sessionId);
    }

    @Override
    public void removeUserId(String sessionId) {
        userAndSessionMap.removeValue(sessionId);
    }

    @Override
    public Map<String, Boolean> isOnline(Collection<String> userIds) {
        Map<String, Boolean> result = MapUtil.newHashMap(userIds.size());
        for (String userId : userIds) {
            result.put(userId, CollUtil.isNotEmpty(userAndSessionMap.get(userId)));
        }
        return result;
    }

    // endregion

    // region alias

    @Override
    public String getAlias(String sessionId) {
        return aliasAndSessionMap.getKey(sessionId);
    }

    @Override
    public void setAlias(String sessionId, String alias) {
        Session<?> session = sessionMap.get(sessionId);
        if (session == null) {
            return;
        }
        aliasAndSessionMap.removeValue(sessionId);
        aliasAndSessionMap.put(alias, sessionId);
    }

    @Override
    public void removeAlias(String sessionId) {
        aliasAndSessionMap.removeValue(sessionId);
    }

    // endregion

    // region tag

    @Override
    public Collection<String> findTags(String sessionId) {
        return sessionAndTagMap.get(sessionId);
    }

    @Override
    public Collection<String> findTagsByUserId(String userId) {
        Collection<String> sessionIds = userAndSessionMap.get(userId);
        if (CollUtil.isEmpty(sessionIds)) {
            return Collections.emptySet();
        }
        return sessionIds.stream()
                .map(this::findTags)
                .flatMap(Collection::stream)
                .collect(Collectors.toSet());
    }

    // @Override
    // public Collection<String> findSessionIds(Collection<String> tags) {
    //     Set<String> sessionIds = null;
    //     for (String tag : tags) {
    //         Collection<String> tempSessionIds = sessionAndTagMap.getKey(tag);
    //         if (CollUtil.isEmpty(tempSessionIds)) {
    //             return Collections.emptySet();
    //         }
    //
    //         if (sessionIds == null) {
    //             sessionIds = new HashSet<>(tempSessionIds);
    //             continue;
    //         }
    //
    //         sessionIds.retainAll(tempSessionIds);
    //         if (sessionIds.isEmpty()) {
    //             return Collections.emptySet();
    //         }
    //     }
    //     return sessionIds;
    // }

    @Override
    public Collection<String> findSessionsByAnyMatchTags(Collection<String> tags) {
        return tags.stream()
                .map(sessionAndTagMap::getKey)
                .filter(CollUtil::isNotEmpty)
                .flatMap(Collection::stream)
                .collect(Collectors.toSet());
    }

    @Override
    public boolean containAnyTag(@Nonnull String sessionId, @Nonnull Collection<String> tags) {
        Collection<String> existingTags = sessionAndTagMap.get(sessionId);
        return CollUtil.containsAny(existingTags, tags);
    }

    @Override
    public boolean containAllTags(String sessionId, Collection<String> tags) {
        Collection<String> existingTags = sessionAndTagMap.get(sessionId);
        return CollUtil.containsAll(existingTags, tags);
    }

    @Override
    public void setTags(String sessionId, Collection<String> tags) {
        Session<?> session = sessionMap.get(sessionId);
        if (session == null) {
            return;
        }
        sessionAndTagMap.replaceValues(sessionId, tags);
    }

    @Override
    public void addTags(String sessionId, Collection<String> tags) {
        Session<?> session = sessionMap.get(sessionId);
        if (session == null) {
            return;
        }
        sessionAndTagMap.putAll(sessionId, tags);
    }

    @Override
    public void setTagsByUserId(String userId, Collection<String> tags) {
        Collection<String> sessionIds = userAndSessionMap.get(userId);
        if (CollUtil.isEmpty(sessionIds)) {
            return;
        }
        sessionIds.forEach(s -> setTags(s, tags));
    }

    @Override
    public void addTagsByUserId(String userId, Collection<String> tags) {
        Collection<String> sessionIds = userAndSessionMap.get(userId);
        if (CollUtil.isEmpty(sessionIds)) {
            return;
        }
        sessionIds.forEach(s -> addTags(s, tags));
    }

    @Override
    public void removeTags(String sessionId) {
        sessionAndTagMap.removeAll(sessionId);
    }

    @Override
    public void removeTags(String sessionId, Collection<String> tags) {
        Session<?> session = sessionMap.get(sessionId);
        if (session == null) {
            return;
        }
        sessionAndTagMap.removeValues(sessionId, tags);
    }

    @Override
    public void removeTagsByUserId(String userId, Collection<String> tags) {
        Collection<String> sessionIds = userAndSessionMap.get(userId);
        if (CollUtil.isEmpty(sessionIds)) {
            return;
        }
        sessionIds.forEach(s -> removeTags(s, tags));
    }

    // endregion

    // region message

    @Override
    public void broadcastMessage(String cmd, Object payload) {
        sessionMap.entrySet()
                .parallelStream()
                .forEach(entry -> entry.getValue().sendMessage(cmd, payload));
    }

    @Override
    public void sendMessageByUserId(String cmd, Object payload, String userId) {
        Collection<String> sessions = userAndSessionMap.get(userId);
        if (CollUtil.isEmpty(sessions)) {
            return;
        }
        sessions.parallelStream()
                .map(sessionMap::get)
                .forEach(s -> s.sendMessage(cmd, payload));
    }

    @Override
    public void sendMessageByUserIds(String cmd, Object payload, Collection<String> userIds) {
        for (String userId : userIds) {
            sendMessageByUserId(cmd, payload, userId);
        }
    }

    @Override
    public void sendMessageToLoginUsers(String cmd, Object payload) {
        userAndSessionMap.entries()
                .parallelStream()
                .map(Map.Entry::getValue)
                .map(sessionMap::get)
                .forEach(s -> s.sendMessage(cmd, payload));
    }

    @Override
    public void sendMessageByAlias(String cmd, Object payload, String alias) {
        Collection<String> sessionIds = aliasAndSessionMap.get(alias);
        if (sessionIds == null) {
            return;
        }
        sessionIds.parallelStream()
                .map(sessionMap::get)
                .forEach(s -> s.sendMessage(cmd, payload));
    }

    @Override
    public void sendMessageByAlias(String cmd, Object payload, Collection<String> aliases) {
        Set<String> sentSessionIds = new HashSet<>();
        for (String alias : aliases) {
            Collection<String> sessionIds = aliasAndSessionMap.get(alias);
            if (sessionIds == null) {
                continue;
            }
            for (String sessionId : sessionIds) {
                if (sentSessionIds.contains(sessionId)) {
                    continue;
                }
                sentSessionIds.add(sessionId);
                Session<?> session = sessionMap.get(sessionId);
                if (session == null) {
                    continue;
                }
                session.sendMessage(cmd, payload);
            }
        }
    }

    @Override
    public void sendMessageByTag(String cmd, Object payload, String tag) {
        Collection<String> sessionIds = sessionAndTagMap.getKey(tag);
        if (sessionIds == null) {
            return;
        }
        sessionIds.parallelStream()
                .map(sessionMap::get)
                .forEach(s -> s.sendMessage(cmd, payload));
    }

    @Override
    public void sendMessageByTags(String cmd, Object payload, Collection<String> tags) {
        Set<String> sentSessionIds = new HashSet<>();
        for (String tag : tags) {
            Collection<String> sessionIds = sessionAndTagMap.getKey(tag);
            if (CollUtil.isEmpty(sessionIds)) {
                continue;
            }

            for (String sessionId : sessionIds) {
                if (sentSessionIds.contains(sessionId)) {
                    continue;
                }
                sentSessionIds.add(sessionId);
                Session<?> session = sessionMap.get(sessionId);
                if (session == null) {
                    continue;
                }
                session.sendMessage(cmd, payload);
            }
        }
    }

    @Override
    public void sendMessageByAnyTags(String cmd, Object payload, Collection<String> tags) {
        Map<String, Boolean> sentSessionIds = new ConcurrentHashMap<>();
        for (String tag : tags) {
            Collection<String> sessionIds = sessionAndTagMap.getKey(tag);
            if (sessionIds == null) {
                continue;
            }

            sessionIds.parallelStream()
                    .filter(s -> sentSessionIds.putIfAbsent(s, Boolean.TRUE) == null)
                    .map(sessionMap::get)
                    .forEach(s -> s.sendMessage(cmd, payload));
        }
    }

    /**
     * 发送消息
     * todo session 对象添加发送二进制消息的方法，避免循环发送消息时多次重复的消息序列化
     * 因发送消息是高频调用接口，里面又有大量集合的判断，为避免集合不必要的复制，所以逻辑比较冗长
     *
     * @param message 消息
     */
    @Override
    public void sendMessage(Message message) {
        // 1：判断 receiverSession 和 receiverSessionId
        if (message.getReceiverSession() != null) {
            message.getReceiverSession().sendMessage(message.getCmd(), message.getPayload());
            return;
        }
        if (StrUtil.isNotBlank(message.getReceiverSessionId())) {
            Session<?> session = sessionMap.get(message.getReceiverSessionId());
            if (session == null) {
                return;
            }
            session.sendMessage(message.getCmd(), message.getPayload());
            return;
        }

        // 2：判断 userId
        Set<String> finalSessionIds = null;
        boolean modifiable = false; // finalSessionIds 是否可修改的集合
        if (CollUtil.isNotEmpty(message.getUserIds())) {
            for (String userId : message.getUserIds()) {
                Collection<String> sessionIdsFromUserId = userAndSessionMap.get(userId);
                if (CollUtil.isEmpty(sessionIdsFromUserId)) {
                    continue;
                }
                if (finalSessionIds == null) {
                    if (sessionIdsFromUserId instanceof Set) {
                        finalSessionIds = (Set<String>) sessionIdsFromUserId;
                    } else {
                        finalSessionIds = new HashSet<>(sessionIdsFromUserId);
                        modifiable = true;
                    }
                } else {
                    if (modifiable) {
                        finalSessionIds.addAll(sessionIdsFromUserId);
                    } else {
                        finalSessionIds = new HashSet<>(finalSessionIds);
                        modifiable = true;
                    }
                }
            }

            if (finalSessionIds == null) {
                return;
            }
        }

        // 3：叠加判断 alias
        if (CollUtil.isNotEmpty(message.getAliases())) {
            for (String alias : message.getAliases()) {
                Collection<String> sessionIdsFromAlias = aliasAndSessionMap.get(alias);
                if (CollUtil.isEmpty(sessionIdsFromAlias)) {
                    continue;
                }

                // 如果 userId 和 alias 都设置了，则判断其交集
                if (finalSessionIds == null) {
                    if (sessionIdsFromAlias instanceof Set) {
                        finalSessionIds = (Set<String>) sessionIdsFromAlias;
                    } else {
                        finalSessionIds = new HashSet<>(sessionIdsFromAlias);
                        modifiable = true;
                    }
                } else {
                    if (!modifiable) {
                        finalSessionIds = new HashSet<>(finalSessionIds);
                        modifiable = true;
                    }
                    finalSessionIds.retainAll(sessionIdsFromAlias);
                    if (finalSessionIds.isEmpty()) {
                        return;
                    }
                }
            }

            if (CollUtil.isEmpty(finalSessionIds)) {
                return;
            }
        }

        // 4：叠加判断 tags
        if (CollUtil.isNotEmpty(message.getTags())) {
            for (String tag : message.getTags()) {
                Collection<String> sessionIdsFromKey = sessionAndTagMap.getKey(tag);
                if (CollUtil.isEmpty(sessionIdsFromKey)) {
                    return;
                }

                // 如果上一步找到了sessionId，则判断此步找到的sessionId是否被上一步的包含
                if (finalSessionIds == null) {
                    if (sessionIdsFromKey instanceof Set) {
                        finalSessionIds = (Set<String>) sessionIdsFromKey;
                    } else {
                        finalSessionIds = new HashSet<>(sessionIdsFromKey);
                        modifiable = true;
                    }
                } else {
                    if (!modifiable) {
                        finalSessionIds = new HashSet<>(finalSessionIds);
                        modifiable = true;
                    }
                    finalSessionIds.retainAll(sessionIdsFromKey);
                    if (finalSessionIds.isEmpty()) {
                        return;
                    }
                }
            }

            // 因为设置了 tags，所以忽略判断 tagsAny，如果 finalSessionIds 非空，则给这些会话发送消息
            if (!finalSessionIds.isEmpty()) {
                finalSessionIds.parallelStream()
                        .map(sessionMap::get)
                        .filter(Objects::nonNull)
                        .forEach(s -> s.sendMessage(message.getCmd(), message.getPayload()));
            }
            return;
        }

        // 5：叠加判断 tagsAny
        if (CollUtil.isNotEmpty(message.getTagsAny())) {
            Map<String, Boolean> sentSessionIds = new ConcurrentHashMap<>();
            for (String tag : message.getTagsAny()) {
                Collection<String> sessionIdsFromKey = sessionAndTagMap.getKey(tag);
                if (CollUtil.isEmpty(sessionIdsFromKey)) {
                    continue;
                }

                if (finalSessionIds.isEmpty()) {
                    sessionIdsFromKey.parallelStream()
                            .filter(s -> sentSessionIds.putIfAbsent(s, Boolean.TRUE) == null)
                            .map(sessionMap::get)
                            .filter(Objects::nonNull)
                            .forEach(s -> s.sendMessage(message.getCmd(), message.getPayload()));
                } else {
                    Collection<String> firstColl;
                    Collection<String> secondColl;
                    if (sessionIdsFromKey.size() > finalSessionIds.size()) {
                        firstColl = finalSessionIds;
                        secondColl = sessionIdsFromKey;
                    } else {
                        firstColl = sessionIdsFromKey;
                        secondColl = finalSessionIds;
                    }
                    for (String loopSessionId : firstColl) {
                        if (secondColl.contains(loopSessionId)
                                && sentSessionIds.putIfAbsent(loopSessionId, Boolean.TRUE) == null) {
                            Session<?> session = sessionMap.get(loopSessionId);
                            if (session != null) {
                                session.sendMessage(message.getCmd(), message.getPayload());
                            }
                        }
                    }
                }
            }
            return;
        }

        // 6：最后方法依然没 return，则广播或者发消息给 finalSessionIds
        if (finalSessionIds == null) {
            broadcastMessage(message.getCmd(), message.getPayload());
        } else {
            finalSessionIds.parallelStream()
                    .map(sessionMap::get)
                    .filter(Objects::nonNull)
                    .forEach(s -> s.sendMessage(message.getCmd(), message.getPayload()));
        }
    }

    @Override
    public void sendMessages(Collection<Message> messages) {
        messages.parallelStream().forEach(this::sendMessage);
    }

    // endregion

}