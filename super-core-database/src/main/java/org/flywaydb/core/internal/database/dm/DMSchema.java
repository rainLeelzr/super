/*
 *                     GNU LESSER GENERAL PUBLIC LICENSE
 *                         Version 3, 29 June 2007
 *
 *   Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 *   Everyone is permitted to copy and distribute verbatim copies
 *   of this license document, but changing it is not allowed.
 *
 *
 *    This version of the GNU Lesser General Public License incorporates
 *  the terms and conditions of version 3 of the GNU General Public
 *  License, supplemented by the additional permissions listed below.
 *
 *    0. Additional Definitions.
 *
 *    As used herein, "this License" refers to version 3 of the GNU Lesser
 *  General Public License, and the "GNU GPL" refers to version 3 of the GNU
 *  General Public License.
 *
 *    "The Library" refers to a covered work governed by this License,
 *  other than an Application or a Combined Work as defined below.
 *
 *    An "Application" is any work that makes use of an interface provided
 *  by the Library, but which is not otherwise based on the Library.
 *  Defining a subclass of a class defined by the Library is deemed a mode
 *  of using an interface provided by the Library.
 *
 *    A "Combined Work" is a work produced by combining or linking an
 *  Application with the Library.  The particular version of the Library
 *  with which the Combined Work was made is also called the "Linked
 *  Version".
 *
 *    The "Minimal Corresponding Source" for a Combined Work means the
 *  Corresponding Source for the Combined Work, excluding any source code
 *  for portions of the Combined Work that, considered in isolation, are
 *  based on the Application, and not on the Linked Version.
 *
 *    The "Corresponding Application Code" for a Combined Work means the
 *  object code and/or source code for the Application, including any data
 *  and utility programs needed for reproducing the Combined Work from the
 *  Application, but excluding the System Libraries of the Combined Work.
 *
 *    1. Exception to Section 3 of the GNU GPL.
 *
 *    You may convey a covered work under sections 3 and 4 of this License
 *  without being bound by section 3 of the GNU GPL.
 *
 *    2. Conveying Modified Versions.
 *
 *    If you modify a copy of the Library, and, in your modifications, a
 *  facility refers to a function or data to be supplied by an Application
 *  that uses the facility (other than as an argument passed when the
 *  facility is invoked), then you may convey a copy of the modified
 *  version:
 *
 *     a) under this License, provided that you make a good faith effort to
 *     ensure that, in the event an Application does not supply the
 *     function or data, the facility still operates, and performs
 *     whatever part of its purpose remains meaningful, or
 *
 *     b) under the GNU GPL, with none of the additional permissions of
 *     this License applicable to that copy.
 *
 *    3. Object Code Incorporating Material from Library Header Files.
 *
 *    The object code form of an Application may incorporate material from
 *  a header file that is part of the Library.  You may convey such object
 *  code under terms of your choice, provided that, if the incorporated
 *  material is not limited to numerical parameters, data structure
 *  layouts and accessors, or small macros, inline functions and templates
 *  (ten or fewer lines in length), you do both of the following:
 *
 *     a) Give prominent notice with each copy of the object code that the
 *     Library is used in it and that the Library and its use are
 *     covered by this License.
 *
 *     b) Accompany the object code with a copy of the GNU GPL and this license
 *     document.
 *
 *    4. Combined Works.
 *
 *    You may convey a Combined Work under terms of your choice that,
 *  taken together, effectively do not restrict modification of the
 *  portions of the Library contained in the Combined Work and reverse
 *  engineering for debugging such modifications, if you also do each of
 *  the following:
 *
 *     a) Give prominent notice with each copy of the Combined Work that
 *     the Library is used in it and that the Library and its use are
 *     covered by this License.
 *
 *     b) Accompany the Combined Work with a copy of the GNU GPL and this license
 *     document.
 *
 *     c) For a Combined Work that displays copyright notices during
 *     execution, include the copyright notice for the Library among
 *     these notices, as well as a reference directing the user to the
 *     copies of the GNU GPL and this license document.
 *
 *     d) Do one of the following:
 *
 *         0) Convey the Minimal Corresponding Source under the terms of this
 *         License, and the Corresponding Application Code in a form
 *         suitable for, and under terms that permit, the user to
 *         recombine or relink the Application with a modified version of
 *         the Linked Version to produce a modified Combined Work, in the
 *         manner specified by section 6 of the GNU GPL for conveying
 *         Corresponding Source.
 *
 *         1) Use a suitable shared library mechanism for linking with the
 *         Library.  A suitable mechanism is one that (a) uses at run time
 *         a copy of the Library already present on the user's computer
 *         system, and (b) will operate properly with a modified version
 *         of the Library that is interface-compatible with the Linked
 *         Version.
 *
 *     e) Provide Installation Information, but only if you would otherwise
 *     be required to provide such information under section 6 of the
 *     GNU GPL, and only to the extent that such information is
 *     necessary to install and execute a modified version of the
 *     Combined Work produced by recombining or relinking the
 *     Application with a modified version of the Linked Version. (If
 *     you use option 4d0, the Installation Information must accompany
 *     the Minimal Corresponding Source and Corresponding Application
 *     Code. If you use option 4d1, you must provide the Installation
 *     Information in the manner specified by section 6 of the GNU GPL
 *     for conveying Corresponding Source.)
 *
 *    5. Combined Libraries.
 *
 *    You may place library facilities that are a work based on the
 *  Library side by side in a single library together with other library
 *  facilities that are not Applications and are not covered by this
 *  License, and convey such a combined library under terms of your
 *  choice, if you do both of the following:
 *
 *     a) Accompany the combined library with a copy of the same work based
 *     on the Library, uncombined with any other library facilities,
 *     conveyed under the terms of this License.
 *
 *     b) Give prominent notice with the combined library that part of it
 *     is a work based on the Library, and explaining where to find the
 *     accompanying uncombined form of the same work.
 *
 *    6. Revised Versions of the GNU Lesser General Public License.
 *
 *    The Free Software Foundation may publish revised and/or new versions
 *  of the GNU Lesser General Public License from time to time. Such new
 *  versions will be similar in spirit to the present version, but may
 *  differ in detail to address new problems or concerns.
 *
 *    Each version is given a distinguishing version number. If the
 *  Library as you received it specifies that a certain numbered version
 *  of the GNU Lesser General Public License "or any later version"
 *  applies to it, you have the option of following the terms and
 *  conditions either of that published version or of any later version
 *  published by the Free Software Foundation. If the Library as you
 *  received it does not specify a version number of the GNU Lesser
 *  General Public License, you may choose any version of the GNU Lesser
 *  General Public License ever published by the Free Software Foundation.
 *
 *    If the Library as you received it specifies that a proxy can decide
 *  whether future versions of the GNU Lesser General Public License shall
 *  apply, that proxy's public statement of acceptance of any version is
 *  permanent authorization for you to choose that version for the
 *  Library.
 *
 */

package org.flywaydb.core.internal.database.dm;

import org.flywaydb.core.api.FlywayException;
import org.flywaydb.core.api.logging.Log;
import org.flywaydb.core.api.logging.LogFactory;
import org.flywaydb.core.internal.database.base.Schema;
import org.flywaydb.core.internal.database.base.Table;
import org.flywaydb.core.internal.jdbc.JdbcTemplate;
import org.flywaydb.core.internal.util.StringUtils;

import java.sql.SQLException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.ASSEMBLY;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.CLUSTER;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.CONTEXT;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.CREDENTIAL;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.CUBE;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.CUBE_BUILD_PROCESS;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.CUBE_DIMENSION;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.DATABASE_DESTINATION;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.DATABASE_LINK;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.DIMENSION;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.DOMAIN_INDEX;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.DOMAIN_INDEX_TYPE;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.EVALUATION_CONTEXT;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.FILE_GROUP;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.FILE_WATCHER;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.FUNCTION;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.INDEX;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.JAVA_CLASS;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.JAVA_DATA;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.JAVA_RESOURCE;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.JAVA_SOURCE;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.LIBRARY;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.MATERIALIZED_VIEW;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.MATERIALIZED_VIEW_LOG;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.MEASURE_FOLDER;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.MINING_MODEL;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.OPERATOR;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.PACKAGE;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.PROCEDURE;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.QUEUE_TABLE;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.REWRITE_EQUIVALENCE;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.RULE;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.RULE_SET;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.SCHEDULE;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.SCHEDULER_CHAIN;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.SCHEDULER_GROUP;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.SCHEDULER_JOB;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.SCHEDULER_PROGRAM;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.SEQUENCE;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.SQL_TRANSLATION_PROFILE;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.SYNONYM;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.TABLE;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.TRIGGER;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.TYPE;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.VIEW;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.getObjectTypeNames;
import static org.flywaydb.core.internal.database.dm.DMSchema.ObjectType.supportedTypesExist;

/**
 * DM implementation of Schema.
 */
public class DMSchema extends Schema<DMDatabase, DMTable> {
    private static final Log LOG = LogFactory.getLog(DMSchema.class);

    /**
     * Creates a new DM schema.
     *
     * @param jdbcTemplate The Jdbc Template for communicating with the DB.
     * @param database     The database-specific support.
     * @param name         The name of the schema.
     */
    DMSchema(JdbcTemplate jdbcTemplate, DMDatabase database, String name) {
        super(jdbcTemplate, database, name);
    }

    /**
     * Checks whether the schema is system, i.e. DM-maintained, or not.
     *
     * @return {@code true} if it is system, {@code false} if not.
     */
    public boolean isSystem() throws SQLException {
        return database.getSystemSchemas().contains(name);
    }

    /**
     * Checks whether this schema is default for the current user.
     *
     * @return {@code true} if it is default, {@code false} if not.
     */
    boolean isDefaultSchemaForUser() throws SQLException {
        return name.equals(database.doGetCurrentUser());
    }

    @Override
    protected boolean doExists() throws SQLException {
        return database.queryReturnsRows("select * from sysobjects where NAME=? and SUBTYPE$ is null", name);
    }

    @Override
    protected boolean doEmpty() throws SQLException {
        return !supportedTypesExist(jdbcTemplate, database, this);
    }

    @Override
    protected void doCreate() throws SQLException {
        jdbcTemplate.execute("CREATE SCHEMA " + name);
    }

    @Override
    protected void doDrop() throws SQLException {
        jdbcTemplate.execute("DROP SCHEMA " + name);
    }

    @Override
    protected void doClean() throws SQLException {
        if (isSystem()) {
            throw new FlywayException("Clean not supported on DM for system schema " + database.quote(name) + "! " +
                "It must not be changed in any way except by running an DM-supplied script!");
        }

        // Disable FBA for schema tables.
        if (database.isFlashbackDataArchiveAvailable()) {
            disableFlashbackArchiveForFbaTrackedTables();
        }

        // Clean DM Locator metadata.
        if (database.isLocatorAvailable()) {
            cleanLocatorMetadata();
        }

        // Get existing object types in the schema.
        Set<String> objectTypeNames = getObjectTypeNames(jdbcTemplate, database, this);

        // Define the list of types to process, order is important.
        List<ObjectType> objectTypesToClean = Arrays.asList(
            TRIGGER,
            QUEUE_TABLE,
            FILE_WATCHER,
            SCHEDULER_CHAIN,
            SCHEDULER_JOB,
            SCHEDULER_PROGRAM,
            SCHEDULE,
            RULE_SET,
            RULE,
            EVALUATION_CONTEXT,
            FILE_GROUP,
            MINING_MODEL,
            REWRITE_EQUIVALENCE,
            SQL_TRANSLATION_PROFILE,
            MATERIALIZED_VIEW,
            MATERIALIZED_VIEW_LOG,
            DIMENSION,
            VIEW,
            DOMAIN_INDEX,
            DOMAIN_INDEX_TYPE,
            TABLE,
            INDEX,
            CLUSTER,
            SEQUENCE,
            OPERATOR,
            FUNCTION,
            PROCEDURE,
            PACKAGE,
            CONTEXT,
            LIBRARY,
            TYPE,
            SYNONYM,
            JAVA_SOURCE,
            JAVA_CLASS,
            JAVA_RESOURCE,

            // Object types with sensitive information (passwords), skip intentionally, print warning if found.
            DATABASE_LINK,
            CREDENTIAL,

            // Unsupported types, print warning if found
            DATABASE_DESTINATION,
            SCHEDULER_GROUP,
            CUBE,
            CUBE_DIMENSION,
            CUBE_BUILD_PROCESS,
            MEASURE_FOLDER,

            // Undocumented types, print warning if found
            ASSEMBLY,
            JAVA_DATA
        );

        for (ObjectType objectType : objectTypesToClean) {
            if (objectTypeNames.contains(objectType.getName())) {
                LOG.debug("Cleaning objects of type " + objectType + " ...");
                objectType.dropObjects(jdbcTemplate, database, this);
            }
        }

        if (isDefaultSchemaForUser()) {
            jdbcTemplate.execute("PURGE RECYCLEBIN");
        }
    }

    /**
     * Executes ALTER statements for all tables that have Flashback Archive enabled.
     * Flashback Archive is an asynchronous process so we need to wait until it completes, otherwise cleaning the
     * tables in schema will sometimes fail with ORA-55622 or ORA-55610 depending on the race between
     * Flashback Archive and Java code.
     *
     * @throws SQLException when the statements could not be generated.
     */
    private void disableFlashbackArchiveForFbaTrackedTables() throws SQLException {
        boolean dbaViewAccessible = database.isPrivOrRoleGranted("SELECT ANY DICTIONARY")
            || database.isDataDictViewAccessible("DBA_FLASHBACK_ARCHIVE_TABLES");

        if (!dbaViewAccessible && !isDefaultSchemaForUser()) {
            LOG.warn("Unable to check and disable Flashback Archive for tables in schema " + database.quote(name) +
                " by user \"" + database.doGetCurrentUser() + "\": DBA_FLASHBACK_ARCHIVE_TABLES is not accessible");
            return;
        }

        boolean DM18orNewer = database.getVersion().isAtLeast("18");

        String queryForFbaTrackedTables = "SELECT TABLE_NAME FROM " + (dbaViewAccessible ? "DBA_" : "USER_")
            + "FLASHBACK_ARCHIVE_TABLES WHERE OWNER_NAME = ?"
            + (DM18orNewer ? " AND STATUS='ENABLED'" : "");
        List<String> tableNames = jdbcTemplate.queryForStringList(queryForFbaTrackedTables, name);
        for (String tableName : tableNames) {
            jdbcTemplate.execute("ALTER TABLE " + database.quote(name, tableName) + " NO FLASHBACK ARCHIVE");
            //wait until the tables disappear
            while (database.queryReturnsRows(queryForFbaTrackedTables + " AND TABLE_NAME = ?", name, tableName)) {
                try {
                    LOG.debug("Actively waiting for Flashback cleanup on table: " + database.quote(name, tableName));
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new FlywayException("Waiting for Flashback cleanup interrupted", e);
                }
            }
        }

        if (DM18orNewer) {
            while (database.queryReturnsRows("SELECT TABLE_NAME FROM ALL_TABLES WHERE OWNER = ?\n"
                + " AND TABLE_NAME LIKE 'SYS_FBA_DDL_COLMAP_%'", name)) {
                try {
                    LOG.debug("Actively waiting for Flashback colmap cleanup");
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new FlywayException("Waiting for Flashback colmap cleanup interrupted", e);
                }
            }
        }
    }

    /**
     * Checks whether DM Locator metadata exists for the schema.
     *
     * @return {@code true} if it exists, {@code false} if not.
     * @throws SQLException when checking metadata existence failed.
     */
    private boolean locatorMetadataExists() throws SQLException {
        return database.queryReturnsRows("SELECT * FROM ALL_SDO_GEOM_METADATA WHERE OWNER = ?", name);
    }

    /**
     * Clean DM Locator metadata for the schema. Works only for the user's default schema, prints a warning message
     * to log otherwise.
     *
     * @throws SQLException when performing cleaning failed.
     */
    private void cleanLocatorMetadata() throws SQLException {
        if (!locatorMetadataExists()) {
            return;
        }

        if (!isDefaultSchemaForUser()) {
            LOG.warn("Unable to clean DM Locator metadata for schema " + database.quote(name) +
                " by user \"" + database.doGetCurrentUser() + "\": unsupported operation");
            return;
        }

        jdbcTemplate.getConnection().commit();
        jdbcTemplate.execute("DELETE FROM USER_SDO_GEOM_METADATA");
        jdbcTemplate.getConnection().commit();
    }

    @Override
    protected DMTable[] doAllTables() throws SQLException {
        List<String> tableNames = TABLE.getObjectNames(jdbcTemplate, database, this);

        DMTable[] tables = new DMTable[tableNames.size()];
        for (int i = 0; i < tableNames.size(); i++) {
            tables[i] = new DMTable(jdbcTemplate, database, this, tableNames.get(i));
        }
        return tables;
    }

    @Override
    public Table getTable(String tableName) {
        return new DMTable(jdbcTemplate, database, this, tableName);
    }


    /**
     * DM object types.
     */
    public enum ObjectType {
        // Tables, including XML tables, except for nested tables, IOT overflow tables and other secondary objects.
        TABLE("TABLE", "CASCADE CONSTRAINTS PURGE") {
            @Override
            public List<String> getObjectNames(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) throws SQLException {
                boolean referencePartitionedTablesExist = database.queryReturnsRows(
                    "SELECT * FROM ALL_PART_TABLES WHERE OWNER = ? AND PARTITIONING_TYPE = 'REFERENCE'",
                    schema.getName());

                StringBuilder tablesQuery = new StringBuilder();
                tablesQuery.append("WITH TABLES AS (\n" +
                    "  SELECT TABLE_NAME, OWNER\n" +
                    "  FROM ALL_TABLES\n" +
                    "  WHERE OWNER = ?\n" +
                    "    AND (IOT_TYPE IS NULL OR IOT_TYPE NOT LIKE '%OVERFLOW%')\n" +
                    "    AND NESTED != 'YES'\n" +
                    "    AND SECONDARY != 'Y'\n");
                tablesQuery.append(")\n" +
                    "SELECT t.TABLE_NAME\n" +
                    "FROM TABLES t\n");

                // Reference partitioned tables should be dropped in child-to-parent order.
                if (referencePartitionedTablesExist) {
                    tablesQuery.append("  LEFT JOIN ALL_PART_TABLES pt\n" +
                        "    ON t.OWNER = pt.OWNER\n" +
                        "   AND t.TABLE_NAME = pt.TABLE_NAME\n" +
                        "   AND pt.PARTITIONING_TYPE = 'REFERENCE'\n" +
                        "  LEFT JOIN ALL_CONSTRAINTS fk\n" +
                        "    ON pt.OWNER = fk.OWNER\n" +
                        "   AND pt.TABLE_NAME = fk.TABLE_NAME\n" +
                        "   AND pt.REF_PTN_CONSTRAINT_NAME = fk.CONSTRAINT_NAME\n" +
                        "   AND fk.CONSTRAINT_TYPE = 'R'\n" +
                        "  LEFT JOIN ALL_CONSTRAINTS puk\n" +
                        "    ON fk.R_OWNER = puk.OWNER\n" +
                        "   AND fk.R_CONSTRAINT_NAME = puk.CONSTRAINT_NAME\n" +
                        "   AND puk.CONSTRAINT_TYPE IN ('P', 'U')\n" +
                        "  LEFT JOIN TABLES p\n" +
                        "    ON puk.OWNER = p.OWNER\n" +
                        "   AND puk.TABLE_NAME = p.TABLE_NAME\n" +
                        "START WITH p.TABLE_NAME IS NULL\n" +
                        "CONNECT BY PRIOR t.TABLE_NAME = p.TABLE_NAME\n" +
                        "ORDER BY LEVEL DESC");
                }

                int n = 1;
                String[] params = new String[n];
                Arrays.fill(params, schema.getName());

                return jdbcTemplate.queryForStringList(tablesQuery.toString(), params);
            }
        },

        // Queue tables, have related objects and should be dropped separately prior to other types.
        QUEUE_TABLE("QUEUE TABLE") {
            @Override
            public List<String> getObjectNames(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) throws SQLException {
                return jdbcTemplate.queryForStringList(
                    "SELECT QUEUE_TABLE FROM ALL_QUEUE_TABLES WHERE OWNER = ?",
                    schema.getName()
                );
            }

            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "BEGIN DBMS_AQADM.DROP_QUEUE_TABLE('" + database.quote(schema.getName(), objectName) + "', FORCE => TRUE); END;";
            }
        },

        // Materialized view logs.
        MATERIALIZED_VIEW_LOG("MATERIALIZED VIEW LOG") {
            @Override
            public List<String> getObjectNames(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) throws SQLException {
                return jdbcTemplate.queryForStringList(
                    "SELECT MASTER FROM ALL_MVIEW_LOGS WHERE LOG_OWNER = ?",
                    schema.getName()
                );
            }

            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "DROP " + this.getName() + " ON " + database.quote(schema.getName(), objectName);
            }
        },

        // All indexes, except for domain indexes, should be dropped after tables (if any left).
        INDEX("INDEX") {
            @Override
            public List<String> getObjectNames(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) throws SQLException {
                return jdbcTemplate.queryForStringList(
                    "SELECT INDEX_NAME FROM ALL_INDEXES WHERE OWNER = ?" +
                        //" AND INDEX_NAME NOT LIKE 'SYS_C%'"+
                        " AND INDEX_TYPE NOT LIKE '%DOMAIN%'",
                    schema.getName()
                );
            }
        },

        // Domain indexes, have related objects and should be dropped separately prior to tables.
        DOMAIN_INDEX("INDEX", "FORCE") {
            @Override
            public List<String> getObjectNames(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) throws SQLException {
                return jdbcTemplate.queryForStringList(
                    "SELECT INDEX_NAME FROM ALL_INDEXES WHERE OWNER = ? AND INDEX_TYPE LIKE '%DOMAIN%'",
                    schema.getName()
                );
            }
        },

        // Domain index types.
        DOMAIN_INDEX_TYPE("INDEXTYPE", "FORCE"),

        // Operators.
        OPERATOR("OPERATOR", "FORCE"),

        // Clusters.
        CLUSTER("CLUSTER", "INCLUDING TABLES CASCADE CONSTRAINTS"),

        // Views, including XML views.
        VIEW("VIEW", "CASCADE CONSTRAINTS"),

        // Materialized views, keep tables as they may be referenced.
        MATERIALIZED_VIEW("MATERIALIZED VIEW", "PRESERVE TABLE"),

        // Dimensions.
        DIMENSION("DIMENSION") {
            @Override
            public List<String> getObjectNames(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) throws SQLException {
                return jdbcTemplate.queryForStringList(
                    "SELECT DIMENSION_NAME FROM ALL_DIMENSIONS WHERE OWNER = ?",
                    schema.getName()
                );
            }
        },

        // Local synonyms.
        SYNONYM("SYNONYM", "FORCE"),

        // Sequences, no filtering for identity sequences, since they get dropped along with master tables.
        SEQUENCE("SEQUENCE"),

        // Procedures, functions, packages.
        PROCEDURE("PROCEDURE"),
        FUNCTION("FUNCTION"),
        PACKAGE("PACKAGE"),

        // Contexts, seen in DBA_CONTEXT view, may remain if DBA_CONTEXT is not accessible.
        CONTEXT("CONTEXT") {
            @Override
            public List<String> getObjectNames(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) throws SQLException {
                return jdbcTemplate.queryForStringList(
                    "SELECT NAMESPACE FROM " + database.dbaOrAll("CONTEXT") + " WHERE SCHEMA = ?",
                    schema.getName()
                );
            }

            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "DROP " + this.getName() + " " + database.quote(objectName); // no owner
            }
        },

        // Triggers of all types, should be dropped at first, because invalid DDL triggers may break the whole clean.
        TRIGGER("TRIGGER"),

        // Types.
        TYPE("TYPE", "FORCE"),

        // Java sources, classes, resources.
        JAVA_SOURCE("JAVA SOURCE"),
        JAVA_CLASS("JAVA CLASS"),
        JAVA_RESOURCE("JAVA RESOURCE"),

        // Libraries.
        LIBRARY("LIBRARY"),

        // Rewrite equivalences.
        REWRITE_EQUIVALENCE("REWRITE EQUIVALENCE") {
            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "BEGIN SYS.DBMS_ADVANCED_REWRITE.DROP_REWRITE_EQUIVALENCE('" + database.quote(schema.getName(), objectName) + "'); END;";
            }
        },

        // SQL translation profiles.
        SQL_TRANSLATION_PROFILE("SQL TRANSLATION PROFILE") {
            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "BEGIN DBMS_SQL_TRANSLATOR.DROP_PROFILE('" + database.quote(schema.getName(), objectName) + "'); END;";
            }
        },

        // Data mining models, have related objects, should be dropped prior to tables.


        MINING_MODEL("MINING MODEL") {
            @Override
            public List<String> getObjectNames(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) throws SQLException {


                return super.getObjectNames(jdbcTemplate, database, schema);


            }

            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "BEGIN DBMS_DATA_MINING.DROP_MODEL('" +


                    database.quote(schema.getName(), objectName)


                    + "'); END;";
            }
        },

        // Scheduler objects.
        SCHEDULER_JOB("JOB") {
            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "BEGIN DBMS_SCHEDULER.DROP_JOB('" + database.quote(schema.getName(), objectName) + "', FORCE => TRUE); END;";
            }
        },
        SCHEDULER_PROGRAM("PROGRAM") {
            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "BEGIN DBMS_SCHEDULER.DROP_PROGRAM('" + database.quote(schema.getName(), objectName) + "', FORCE => TRUE); END;";
            }
        },
        SCHEDULE("SCHEDULE") {
            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "BEGIN DBMS_SCHEDULER.DROP_SCHEDULE('" + database.quote(schema.getName(), objectName) + "', FORCE => TRUE); END;";
            }
        },
        SCHEDULER_CHAIN("CHAIN") {
            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "BEGIN DBMS_SCHEDULER.DROP_CHAIN('" + database.quote(schema.getName(), objectName) + "', FORCE => TRUE); END;";
            }
        },
        FILE_WATCHER("FILE WATCHER") {
            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "BEGIN DBMS_SCHEDULER.DROP_FILE_WATCHER('" + database.quote(schema.getName(), objectName) + "', FORCE => TRUE); END;";
            }
        },

        // Streams/rule objects.
        RULE_SET("RULE SET") {
            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "BEGIN DBMS_RULE_ADM.DROP_RULE_SET('" + database.quote(schema.getName(), objectName) + "', DELETE_RULES => FALSE); END;";
            }
        },
        RULE("RULE") {
            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "BEGIN DBMS_RULE_ADM.DROP_RULE('" + database.quote(schema.getName(), objectName) + "', FORCE => TRUE); END;";
            }
        },
        EVALUATION_CONTEXT("EVALUATION CONTEXT") {
            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "BEGIN DBMS_RULE_ADM.DROP_EVALUATION_CONTEXT('" + database.quote(schema.getName(), objectName) + "', FORCE => TRUE); END;";
            }
        },
        FILE_GROUP("FILE GROUP") {
            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "BEGIN DBMS_FILE_GROUP.DROP_FILE_GROUP('" + database.quote(schema.getName(), objectName) + "'); END;";
            }
        },


        /*** Below are unsupported object types. They should be dropped explicitly in callbacks if used. ***/

        // Database links and credentials, contain sensitive information (password) and hence not always can be re-created.
        // Intentionally skip them and let the clean callbacks handle them if needed.
        DATABASE_LINK("DATABASE LINK") {
            @Override
            public void dropObjects(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) {
                super.warnUnsupported(database.quote(schema.getName()));
            }

            @Override
            public List<String> getObjectNames(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) throws SQLException {
                return jdbcTemplate.queryForStringList(
                    "SELECT DB_LINK FROM " + database.dbaOrAll("DB_LINKS") + " WHERE OWNER = ?",
                    schema.getName()
                );
            }

            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "DROP " + this.getName() + " " + objectName; // db link name is case-insensitive and needs no owner
            }
        },
        CREDENTIAL("CREDENTIAL") {
            @Override
            public void dropObjects(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) {
                super.warnUnsupported(database.quote(schema.getName()));
            }

            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "BEGIN DBMS_SCHEDULER.DROP_CREDENTIAL('" + database.quote(schema.getName(), objectName) + "', FORCE => TRUE); END;";
            }
        },

        // Some scheduler types, not supported yet.
        DATABASE_DESTINATION("DESTINATION") {
            @Override
            public void dropObjects(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) {
                super.warnUnsupported(database.quote(schema.getName()));
            }

            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "BEGIN DBMS_SCHEDULER.DROP_DATABASE_DESTINATION('" + database.quote(schema.getName(), objectName) + "'); END;";
            }
        },
        SCHEDULER_GROUP("SCHEDULER GROUP") {
            @Override
            public void dropObjects(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) {
                super.warnUnsupported(database.quote(schema.getName()));
            }

            @Override
            public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
                return "BEGIN DBMS_SCHEDULER.DROP_GROUP('" + database.quote(schema.getName(), objectName) + "', FORCE => TRUE); END;";
            }
        },

        // OLAP objects, not supported yet.
        CUBE("CUBE") {
            @Override
            public void dropObjects(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) {
                super.warnUnsupported(database.quote(schema.getName()));
            }
        },
        CUBE_DIMENSION("CUBE DIMENSION") {
            @Override
            public void dropObjects(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) {
                super.warnUnsupported(database.quote(schema.getName()));
            }
        },
        CUBE_BUILD_PROCESS("CUBE BUILD PROCESS") {
            @Override
            public void dropObjects(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) {
                super.warnUnsupported(database.quote(schema.getName()), "cube build processes");
            }
        },
        MEASURE_FOLDER("MEASURE FOLDER") {
            @Override
            public void dropObjects(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) {
                super.warnUnsupported(database.quote(schema.getName()));
            }
        },

        // Undocumented objects.
        ASSEMBLY("ASSEMBLY") {
            @Override
            public void dropObjects(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) {
                super.warnUnsupported(database.quote(schema.getName()), "assemblies");
            }
        },
        JAVA_DATA("JAVA DATA") {
            @Override
            public void dropObjects(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) {
                super.warnUnsupported(database.quote(schema.getName()));
            }
        },

        // SYS-owned objects, cannot be dropped when a schema gets cleaned, simply ignore them.
        CAPTURE("CAPTURE"),
        APPLY("APPLY"),
        DIRECTORY("DIRECTORY"),
        RESOURCE_PLAN("RESOURCE PLAN"),
        CONSUMER_GROUP("CONSUMER GROUP"),
        JOB_CLASS("JOB CLASS"),
        WINDOWS("WINDOW"),
        EDITION("EDITION"),
        AGENT_DESTINATION("DESTINATION"),
        UNIFIED_AUDIT_POLICY("UNIFIED AUDIT POLICY");

        /**
         * The name of the type as it mentioned in the Data Dictionary and the DROP statement.
         */
        private final String name;

        /**
         * The extra options used in the DROP statement to enforce the operation.
         */
        private final String dropOptions;

        ObjectType(String name, String dropOptions) {
            this.name = name;
            this.dropOptions = dropOptions;
        }

        ObjectType(String name) {
            this(name, "");
        }

        public String getName() {
            return name;
        }

        @Override
        public String toString() {
            return super.toString().replace('_', ' ');
        }

        /**
         * Returns the list of object names of this type.
         *
         * @throws SQLException if retrieving of objects failed.
         */
        public List<String> getObjectNames(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) throws SQLException {
            return jdbcTemplate.queryForStringList(
                "SELECT DISTINCT OBJECT_NAME FROM ALL_OBJECTS WHERE OWNER = ? AND OBJECT_TYPE = ?",
                schema.getName(), this.getName()
            );
        }

        /**
         * Generates the drop statement for the specified object.
         */
        public String generateDropStatement(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema, String objectName) {
            return "DROP " + this.getName() + " " + database.quote(schema.getName(), objectName) +
                (StringUtils.hasText(dropOptions) ? " " + dropOptions : "");
        }

        /**
         * Drops all objects of this type in the specified schema.
         *
         * @throws SQLException if cleaning failed.
         */
        public void dropObjects(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) throws SQLException {
            for (String objectName : getObjectNames(jdbcTemplate, database, schema)) {
                jdbcTemplate.execute(generateDropStatement(jdbcTemplate, database, schema, objectName));
            }
        }

        private void warnUnsupported(String schemaName, String typeDesc) {
            LOG.warn("Unable to clean " + typeDesc + " for schema " + schemaName + ": unsupported operation");
        }

        private void warnUnsupported(String schemaName) {
            warnUnsupported(schemaName, this.toString().toLowerCase() + "s");
        }

        /**
         * Returns the schema's existing object types.
         *
         * @return a set of object type names.
         * @throws SQLException if retrieving of object types failed.
         */
        public static Set<String> getObjectTypeNames(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) throws SQLException {
            // 某模式下所有表名 需要DBA权限          AND SEGMENT_NAME LIKE 'CD_%'\n"
            String query = "select SEGMENT_NAME as tbName from dba_segments  where segment_type='TABLE' and OWNER =? ";
            int n = 1;
            String[] params = new String[n];
            Arrays.fill(params, schema.getName());
            return new HashSet<>(jdbcTemplate.queryForStringList(query, params));
        }

        /**
         * Checks whether the specified schema contains object types that can be cleaned.
         * 检查 schema 是否为空
         *
         * @return {@code true} if it contains, {@code false} if not.
         * @throws SQLException if retrieving of object types failed.
         */
        public static boolean supportedTypesExist(JdbcTemplate jdbcTemplate, DMDatabase database, DMSchema schema) throws SQLException {
            Set<String> existingTypeNames = new HashSet<>(getObjectTypeNames(jdbcTemplate, database, schema));
            return !existingTypeNames.isEmpty();
        }
    }
}